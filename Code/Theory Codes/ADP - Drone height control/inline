{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "1de4bded",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import math\n",
    "import scipy as sp\n",
    "import control as ct\n",
    "import control.matlab as matlab\n",
    "from HelperFunctions import *\n",
    "from scipy.signal import butter, lfilter"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "b7c5cee5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define the Space state model. X = [x, x_dot] U = [u*] Y = [x], x = [height], u* = [thrust + gravity]\n",
    "# Gravity applied only to Z double dot\n",
    "\n",
    "sim_dur = 100\n",
    "sample_rate = 1000 # Hz\n",
    "t = np.linspace(0, sim_dur, int(sim_dur*sample_rate), endpoint=False)\n",
    "\n",
    "g = 9.81\n",
    "tau1 = 0.2 # The units are 1/sec  -- value of 10 was giving a weird response\n",
    "m = 2 # The units are kg\n",
    "a = 10 \n",
    "\n",
    "A1 = np.array([[0, 1, 0], [0, 0, 1/m], [0, 0, -1/tau1]])\n",
    "B = np.array([[0], [0], [a]])\n",
    "L = np.array([[0], [-1], [0]])\n",
    "C = np.array([[1, 0, 0]])\n",
    "D = np.array([[0]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "0bc9b3e0",
   "metadata": {},
   "outputs": [],
   "source": [
    "Q_lqr = np.array([[5, 0, 0],[0, 1, 0], [0, 0, 1]])\n",
    "R_lqr = 1\n",
    "K_lqr1, P_lqr1, E1 = matlab.lqr(A1, B, Q_lqr, R_lqr)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "6aa58023",
   "metadata": {},
   "outputs": [],
   "source": [
    "iterations = len(t)\n",
    "T = 1/iterations\n",
    "# Wanted height:\n",
    "h = 10\n",
    "\n",
    "# requested state:\n",
    "r = np.array([[h], [0], [0]])\n",
    "\n",
    "# First, define the system dynamics for both systems\n",
    "def system(state, t, A, B, K, r, L, g):\n",
    "    # state is the current state vector\n",
    "    # Calculate control input u = -K(x-r)\n",
    "    u = -K @ (state.reshape(-1,1) - r)\n",
    "    # Calculate state derivative\n",
    "    state_dot = (A @ state.reshape(-1,1) + B * u.item() + L * g).flatten()\n",
    "    return state_dot\n",
    "\n",
    "# Initial conditions\n",
    "x1_0 = np.zeros(np.size(A1,0))  # Initial state for system 1\n",
    "\n",
    "# Solve ODEs\n",
    "x1_solution = sp.integrate.odeint(system, x1_0, t, args=(A1, B, K_lqr1, r, L, 0))\n",
    "\n",
    "# Extract states (x1_solution and x2_solution will be arrays of shape (iterations, 3))\n",
    "# If you need column vectors, reshape:\n",
    "x1_ = x1_solution.T.reshape(3, iterations, 1)\n",
    "\n",
    "# Calculate control inputs\n",
    "u1_ = np.zeros(iterations)\n",
    "for i in range(iterations):\n",
    "    u1_[i] = (-K_lqr1 @ (x1_[:,i]-r)).item()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "fdb1d9e2",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_[0,:], label='Height')\n",
    "plt.plot(t, x1_[1,:], label='Velocity')\n",
    "plt.plot(t, x1_[2,:], label='Motor Dynamics')\n",
    "plt.plot(t, u1_, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Height')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "ac548e88",
   "metadata": {},
   "outputs": [],
   "source": [
    "u_adp = create_input_signal(t, noise_std=50, noise_freq=100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "74e734f7",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('PWM Signal')\n",
    "plt.title('Input Signal')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "1f2a5a46",
   "metadata": {},
   "outputs": [],
   "source": [
    "def system_adp(state, t, A, B, u_func, t_vec, L, g):\n",
    "    # Interpolate u at the current time point\n",
    "    u = np.interp(t, t_vec, u_func)\n",
    "    # Calculate state derivative\n",
    "    state_dot = (A @ state.reshape(-1,1) + B * u + L * g).flatten()\n",
    "    return state_dot\n",
    "\n",
    "# Initial conditions\n",
    "x1_0_adp = np.zeros(np.size(A1,0))\n",
    "\n",
    "# Solve ODEs\n",
    "x1_solution_adp = sp.integrate.odeint(system_adp, x1_0_adp, t, \n",
    "                                    args=(A1, B, u_adp, t, L, g))\n",
    "\n",
    "# Reshape solutions to match your original format\n",
    "x1_adp = x1_solution_adp.T\n",
    "\n",
    "# If you need x_dot values, you can calculate them:\n",
    "x_dot1_adp = np.zeros_like(x1_adp)\n",
    "\n",
    "for i in range(len(t)):\n",
    "    x_dot1_adp[:,i] = system_adp(x1_adp[:,i], t[i], A1, B, u_adp, t, L, g)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "51e112f4",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 0.1 # Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "9c610dc7",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "48273212",
   "metadata": {},
   "outputs": [],
   "source": [
    "u_adp = create_input_signal(t, noise_std=50, noise_freq=100, cycle_time=5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "829260bc",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('PWM Signal')\n",
    "plt.title('Input Signal')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "2a2f75fe",
   "metadata": {},
   "outputs": [],
   "source": [
    "def system_adp(state, t, A, B, u_func, t_vec, L, g):\n",
    "    # Interpolate u at the current time point\n",
    "    u = np.interp(t, t_vec, u_func)\n",
    "    # Calculate state derivative\n",
    "    state_dot = (A @ state.reshape(-1,1) + B * u + L * g).flatten()\n",
    "    return state_dot\n",
    "\n",
    "# Initial conditions\n",
    "x1_0_adp = np.zeros(np.size(A1,0))\n",
    "\n",
    "# Solve ODEs\n",
    "x1_solution_adp = sp.integrate.odeint(system_adp, x1_0_adp, t, \n",
    "                                    args=(A1, B, u_adp, t, L, g))\n",
    "\n",
    "# Reshape solutions to match your original format\n",
    "x1_adp = x1_solution_adp.T\n",
    "\n",
    "# If you need x_dot values, you can calculate them:\n",
    "x_dot1_adp = np.zeros_like(x1_adp)\n",
    "\n",
    "for i in range(len(t)):\n",
    "    x_dot1_adp[:,i] = system_adp(x1_adp[:,i], t[i], A1, B, u_adp, t, L, g)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "96cb61d7",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 0.1 # Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "435a6173",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "82d3975c",
   "metadata": {},
   "outputs": [],
   "source": [
    "u_adp = create_input_signal(t, noise_std=10, noise_freq=100, cycle_time=5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "603fa76e",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('PWM Signal')\n",
    "plt.title('Input Signal')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "80ddf8d2",
   "metadata": {},
   "outputs": [],
   "source": [
    "def system_adp(state, t, A, B, u_func, t_vec, L, g):\n",
    "    # Interpolate u at the current time point\n",
    "    u = np.interp(t, t_vec, u_func)\n",
    "    # Calculate state derivative\n",
    "    state_dot = (A @ state.reshape(-1,1) + B * u + L * g).flatten()\n",
    "    return state_dot\n",
    "\n",
    "# Initial conditions\n",
    "x1_0_adp = np.zeros(np.size(A1,0))\n",
    "\n",
    "# Solve ODEs\n",
    "x1_solution_adp = sp.integrate.odeint(system_adp, x1_0_adp, t, \n",
    "                                    args=(A1, B, u_adp, t, L, g))\n",
    "\n",
    "# Reshape solutions to match your original format\n",
    "x1_adp = x1_solution_adp.T\n",
    "\n",
    "# If you need x_dot values, you can calculate them:\n",
    "x_dot1_adp = np.zeros_like(x1_adp)\n",
    "\n",
    "for i in range(len(t)):\n",
    "    x_dot1_adp[:,i] = system_adp(x1_adp[:,i], t[i], A1, B, u_adp, t, L, g)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "993117de",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 0.1 # Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "4182fd58",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "63c7488e",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 0.01 # Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "5bd0d730",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "d234a2bb",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 1 # Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "99d68d09",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "a35d4db3",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 10 # Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "51f152b1",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "a3fb4a00",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 100 # Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "7e1fd78a",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "d10f4b96",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 0.1 # Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "8052f070",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "2d298961",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 0.5# Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "bfd61b21",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "e4515604",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, x1_adp[0,:], label='Height')\n",
    "plt.plot(t, x1_adp[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Height')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "233a0f69",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "# plt.plot(t, x1_adp[0,:], label='Height')\n",
    "plt.plot(t, x1_adp[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Height')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "c0032c68",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "# plt.plot(t, x1_adp[0,:], label='Height')\n",
    "# plt.plot(t, x1_adp[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Height')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "d556385d",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, x1_adp[0,:], label='Height')\n",
    "plt.plot(t, x1_adp[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Height')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "f7089212",
   "metadata": {},
   "outputs": [],
   "source": [
    "kron_xx = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "kron_xu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "delta_x = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "Ixx = np.empty((0, np.size(x1_adp_HPF,0)**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = np.size(x1_adp_HPF,0)*(np.size(x1_adp_HPF,0)+1)//2+np.size(x1_adp_HPF,0)*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l+50)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "fda551fc",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp,0)\n",
    "Q = np.array([[5, 0, 0],[0, 1, 0], [0, 0, 1]])\n",
    "m = 1\n",
    "R_ = np.array([[1]])\n",
    "K_i = 0.2 * K_lqr1 # starting with a stabilizing control value\n",
    "N_ = create_N_matrix(n)\n",
    "\n",
    "K_adp = np.empty((0, np.size(x1_adp,0)))\n",
    "P_adp = []\n",
    "P_i_old = np.zeros_like(Q)\n",
    "\n",
    "norm_Pi = np.array([])\n",
    "\n",
    "for i in range(1,iterations):\n",
    "    # Calculating Q_i:\n",
    "    Q_i = Q + K_i.T @ R_ @ K_i\n",
    "    \n",
    "    # Calculating Y_i:\n",
    "    Y_i = -Ixx @ vec(Q_i) # Shai added - in the begining\n",
    "    X_i = np.hstack((delta_x @ N_, -2* Ixx@np.kron(np.eye(n), K_i.T @ R_) -2*Ixu @ np.kron(np.eye(n), R_)))\n",
    "    \n",
    "    # Calculating Theta_i:\n",
    "    Theta_i = np.linalg.lstsq(X_i, Y_i, rcond=None)[0]\n",
    "    \n",
    "    vecP_i = N_ @ Theta_i[:(n**2-n*m )]\n",
    "    P_i = vec2matrix(vecP_i)\n",
    "    norm_Pi = np.append(norm_Pi, np.linalg.norm(P_i))\n",
    "    \n",
    "    K_i = Theta_i[(n**2-2*m-1):].reshape(K_lqr1.shape)\n",
    "\n",
    "    \n",
    "    K_adp = np.vstack((K_adp, K_i))\n",
    "    P_adp.append(P_i)\n",
    "    \n",
    "    if abs(np.linalg.norm(P_i_old - P_i)) < 0.01:\n",
    "        print('Converged')\n",
    "        \n",
    "        break\n",
    "    \n",
    "    P_i_old = P_i\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "d2deff79",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_adp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "id": "de06898c",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_lqr1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "id": "49f2d422",
   "metadata": {},
   "outputs": [],
   "source": [
    "kron_xx = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "kron_xu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "delta_x = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "Ixx = np.empty((0, np.size(x1_adp_HPF,0)**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = np.size(x1_adp_HPF,0)*(np.size(x1_adp_HPF,0)+1)//2+np.size(x1_adp_HPF,0)*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "id": "2cef89ea",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp,0)\n",
    "Q = np.array([[5, 0, 0],[0, 1, 0], [0, 0, 1]])\n",
    "m = 1\n",
    "R_ = np.array([[1]])\n",
    "K_i = 0.2 * K_lqr1 # starting with a stabilizing control value\n",
    "N_ = create_N_matrix(n)\n",
    "\n",
    "K_adp = np.empty((0, np.size(x1_adp,0)))\n",
    "P_adp = []\n",
    "P_i_old = np.zeros_like(Q)\n",
    "\n",
    "norm_Pi = np.array([])\n",
    "\n",
    "for i in range(1,iterations):\n",
    "    # Calculating Q_i:\n",
    "    Q_i = Q + K_i.T @ R_ @ K_i\n",
    "    \n",
    "    # Calculating Y_i:\n",
    "    Y_i = -Ixx @ vec(Q_i) # Shai added - in the begining\n",
    "    X_i = np.hstack((delta_x @ N_, -2* Ixx@np.kron(np.eye(n), K_i.T @ R_) -2*Ixu @ np.kron(np.eye(n), R_)))\n",
    "    \n",
    "    # Calculating Theta_i:\n",
    "    Theta_i = np.linalg.lstsq(X_i, Y_i, rcond=None)[0]\n",
    "    \n",
    "    vecP_i = N_ @ Theta_i[:(n**2-n*m )]\n",
    "    P_i = vec2matrix(vecP_i)\n",
    "    norm_Pi = np.append(norm_Pi, np.linalg.norm(P_i))\n",
    "    \n",
    "    K_i = Theta_i[(n**2-2*m-1):].reshape(K_lqr1.shape)\n",
    "\n",
    "    \n",
    "    K_adp = np.vstack((K_adp, K_i))\n",
    "    P_adp.append(P_i)\n",
    "    \n",
    "    if abs(np.linalg.norm(P_i_old - P_i)) < 0.01:\n",
    "        print('Converged')\n",
    "        \n",
    "        break\n",
    "    \n",
    "    P_i_old = P_i\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "id": "3c35bad1",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_adp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "id": "9ed20376",
   "metadata": {},
   "outputs": [],
   "source": [
    "kron_xx = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "kron_xu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "delta_x = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "Ixx = np.empty((0, np.size(x1_adp_HPF,0)**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = np.size(x1_adp_HPF,0)*(np.size(x1_adp_HPF,0)+1)//2+np.size(x1_adp_HPF,0)*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l+100)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "id": "118ea850",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp,0)\n",
    "Q = np.array([[5, 0, 0],[0, 1, 0], [0, 0, 1]])\n",
    "m = 1\n",
    "R_ = np.array([[1]])\n",
    "K_i = 0.2 * K_lqr1 # starting with a stabilizing control value\n",
    "N_ = create_N_matrix(n)\n",
    "\n",
    "K_adp = np.empty((0, np.size(x1_adp,0)))\n",
    "P_adp = []\n",
    "P_i_old = np.zeros_like(Q)\n",
    "\n",
    "norm_Pi = np.array([])\n",
    "\n",
    "for i in range(1,iterations):\n",
    "    # Calculating Q_i:\n",
    "    Q_i = Q + K_i.T @ R_ @ K_i\n",
    "    \n",
    "    # Calculating Y_i:\n",
    "    Y_i = -Ixx @ vec(Q_i) # Shai added - in the begining\n",
    "    X_i = np.hstack((delta_x @ N_, -2* Ixx@np.kron(np.eye(n), K_i.T @ R_) -2*Ixu @ np.kron(np.eye(n), R_)))\n",
    "    \n",
    "    # Calculating Theta_i:\n",
    "    Theta_i = np.linalg.lstsq(X_i, Y_i, rcond=None)[0]\n",
    "    \n",
    "    vecP_i = N_ @ Theta_i[:(n**2-n*m )]\n",
    "    P_i = vec2matrix(vecP_i)\n",
    "    norm_Pi = np.append(norm_Pi, np.linalg.norm(P_i))\n",
    "    \n",
    "    K_i = Theta_i[(n**2-2*m-1):].reshape(K_lqr1.shape)\n",
    "\n",
    "    \n",
    "    K_adp = np.vstack((K_adp, K_i))\n",
    "    P_adp.append(P_i)\n",
    "    \n",
    "    if abs(np.linalg.norm(P_i_old - P_i)) < 0.01:\n",
    "        print('Converged')\n",
    "        \n",
    "        break\n",
    "    \n",
    "    P_i_old = P_i\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "2f9f2a30",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_adp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "id": "c327d62e",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 0.1# Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "id": "ed132624",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "id": "07d2c083",
   "metadata": {},
   "outputs": [],
   "source": [
    "kron_xx = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "kron_xu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "delta_x = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "Ixx = np.empty((0, np.size(x1_adp_HPF,0)**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = np.size(x1_adp_HPF,0)*(np.size(x1_adp_HPF,0)+1)//2+np.size(x1_adp_HPF,0)*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l+100)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "id": "161e9a24",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp,0)\n",
    "Q = np.array([[5, 0, 0],[0, 1, 0], [0, 0, 1]])\n",
    "m = 1\n",
    "R_ = np.array([[1]])\n",
    "K_i = 0.2 * K_lqr1 # starting with a stabilizing control value\n",
    "N_ = create_N_matrix(n)\n",
    "\n",
    "K_adp = np.empty((0, np.size(x1_adp,0)))\n",
    "P_adp = []\n",
    "P_i_old = np.zeros_like(Q)\n",
    "\n",
    "norm_Pi = np.array([])\n",
    "\n",
    "for i in range(1,iterations):\n",
    "    # Calculating Q_i:\n",
    "    Q_i = Q + K_i.T @ R_ @ K_i\n",
    "    \n",
    "    # Calculating Y_i:\n",
    "    Y_i = -Ixx @ vec(Q_i) # Shai added - in the begining\n",
    "    X_i = np.hstack((delta_x @ N_, -2* Ixx@np.kron(np.eye(n), K_i.T @ R_) -2*Ixu @ np.kron(np.eye(n), R_)))\n",
    "    \n",
    "    # Calculating Theta_i:\n",
    "    Theta_i = np.linalg.lstsq(X_i, Y_i, rcond=None)[0]\n",
    "    \n",
    "    vecP_i = N_ @ Theta_i[:(n**2-n*m )]\n",
    "    P_i = vec2matrix(vecP_i)\n",
    "    norm_Pi = np.append(norm_Pi, np.linalg.norm(P_i))\n",
    "    \n",
    "    K_i = Theta_i[(n**2-2*m-1):].reshape(K_lqr1.shape)\n",
    "\n",
    "    \n",
    "    K_adp = np.vstack((K_adp, K_i))\n",
    "    P_adp.append(P_i)\n",
    "    \n",
    "    if abs(np.linalg.norm(P_i_old - P_i)) < 0.01:\n",
    "        print('Converged')\n",
    "        \n",
    "        break\n",
    "    \n",
    "    P_i_old = P_i\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "b3891cd8",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_adp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "4be936ec",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 1# Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "92e906c8",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "fb624201",
   "metadata": {},
   "outputs": [],
   "source": [
    "kron_xx = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "kron_xu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "delta_x = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "Ixx = np.empty((0, np.size(x1_adp_HPF,0)**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = np.size(x1_adp_HPF,0)*(np.size(x1_adp_HPF,0)+1)//2+np.size(x1_adp_HPF,0)*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l+100)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "4108b648",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp,0)\n",
    "Q = np.array([[5, 0, 0],[0, 1, 0], [0, 0, 1]])\n",
    "m = 1\n",
    "R_ = np.array([[1]])\n",
    "K_i = 0.2 * K_lqr1 # starting with a stabilizing control value\n",
    "N_ = create_N_matrix(n)\n",
    "\n",
    "K_adp = np.empty((0, np.size(x1_adp,0)))\n",
    "P_adp = []\n",
    "P_i_old = np.zeros_like(Q)\n",
    "\n",
    "norm_Pi = np.array([])\n",
    "\n",
    "for i in range(1,iterations):\n",
    "    # Calculating Q_i:\n",
    "    Q_i = Q + K_i.T @ R_ @ K_i\n",
    "    \n",
    "    # Calculating Y_i:\n",
    "    Y_i = -Ixx @ vec(Q_i) # Shai added - in the begining\n",
    "    X_i = np.hstack((delta_x @ N_, -2* Ixx@np.kron(np.eye(n), K_i.T @ R_) -2*Ixu @ np.kron(np.eye(n), R_)))\n",
    "    \n",
    "    # Calculating Theta_i:\n",
    "    Theta_i = np.linalg.lstsq(X_i, Y_i, rcond=None)[0]\n",
    "    \n",
    "    vecP_i = N_ @ Theta_i[:(n**2-n*m )]\n",
    "    P_i = vec2matrix(vecP_i)\n",
    "    norm_Pi = np.append(norm_Pi, np.linalg.norm(P_i))\n",
    "    \n",
    "    K_i = Theta_i[(n**2-2*m-1):].reshape(K_lqr1.shape)\n",
    "\n",
    "    \n",
    "    K_adp = np.vstack((K_adp, K_i))\n",
    "    P_adp.append(P_i)\n",
    "    \n",
    "    if abs(np.linalg.norm(P_i_old - P_i)) < 0.01:\n",
    "        print('Converged')\n",
    "        \n",
    "        break\n",
    "    \n",
    "    P_i_old = P_i\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "id": "78736085",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_adp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "id": "27d38159",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_lqr1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "id": "64192709",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 0.02# Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "id": "339d7959",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "id": "91b820a6",
   "metadata": {},
   "outputs": [],
   "source": [
    "kron_xx = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "kron_xu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "delta_x = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "Ixx = np.empty((0, np.size(x1_adp_HPF,0)**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = np.size(x1_adp_HPF,0)*(np.size(x1_adp_HPF,0)+1)//2+np.size(x1_adp_HPF,0)*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l+100)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "id": "9d79bdda",
   "metadata": {},
   "outputs": [],
   "source": [
    "kron_xx = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "kron_xu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "delta_x = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "Ixx = np.empty((0, np.size(x1_adp_HPF,0)**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = np.size(x1_adp_HPF,0)*(np.size(x1_adp_HPF,0)+1)//2+np.size(x1_adp_HPF,0)*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "id": "9745a2ee",
   "metadata": {},
   "outputs": [],
   "source": [
    "kron_xx = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "kron_xu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "delta_x = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "Ixx = np.empty((0, np.size(x1_adp_HPF,0)**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = np.size(x1_adp_HPF,0)*(np.size(x1_adp_HPF,0)+1)//2+np.size(x1_adp_HPF,0)*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l+1)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "id": "58fa88e1",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp,0)\n",
    "Q = np.array([[5, 0, 0],[0, 1, 0], [0, 0, 1]])\n",
    "m = 1\n",
    "R_ = np.array([[1]])\n",
    "K_i = 0.2 * K_lqr1 # starting with a stabilizing control value\n",
    "N_ = create_N_matrix(n)\n",
    "\n",
    "K_adp = np.empty((0, np.size(x1_adp,0)))\n",
    "P_adp = []\n",
    "P_i_old = np.zeros_like(Q)\n",
    "\n",
    "norm_Pi = np.array([])\n",
    "\n",
    "for i in range(1,iterations):\n",
    "    # Calculating Q_i:\n",
    "    Q_i = Q + K_i.T @ R_ @ K_i\n",
    "    \n",
    "    # Calculating Y_i:\n",
    "    Y_i = -Ixx @ vec(Q_i) # Shai added - in the begining\n",
    "    X_i = np.hstack((delta_x @ N_, -2* Ixx@np.kron(np.eye(n), K_i.T @ R_) -2*Ixu @ np.kron(np.eye(n), R_)))\n",
    "    \n",
    "    # Calculating Theta_i:\n",
    "    Theta_i = np.linalg.lstsq(X_i, Y_i, rcond=None)[0]\n",
    "    \n",
    "    vecP_i = N_ @ Theta_i[:(n**2-n*m )]\n",
    "    P_i = vec2matrix(vecP_i)\n",
    "    norm_Pi = np.append(norm_Pi, np.linalg.norm(P_i))\n",
    "    \n",
    "    K_i = Theta_i[(n**2-2*m-1):].reshape(K_lqr1.shape)\n",
    "\n",
    "    \n",
    "    K_adp = np.vstack((K_adp, K_i))\n",
    "    P_adp.append(P_i)\n",
    "    \n",
    "    if abs(np.linalg.norm(P_i_old - P_i)) < 0.01:\n",
    "        print('Converged')\n",
    "        \n",
    "        break\n",
    "    \n",
    "    P_i_old = P_i\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "id": "d7f64bb6",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_adp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "id": "739f8a05",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_lqr1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "id": "ed1adfde",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = 1/(t[1]-t[0])\n",
    "cutoff_freq = 0.5# Hz. Trying to remove the gravity\n",
    "\n",
    "\n",
    "# Filter u measurements\n",
    "u_adp_HPF = apply_highpass_filter(u_adp, cutoff_freq, fs)\n",
    "\n",
    "# Filter x measurements (apply to each state)\n",
    "x1_adp_HPF = np.zeros_like(x1_adp)\n",
    "for i in range(x1_adp.shape[0]):\n",
    "    x1_adp_HPF[i,:] = apply_highpass_filter(x1_adp[i,:], cutoff_freq, fs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "id": "89e6fa05",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.figure(figsize=(20,6))\n",
    "plt.plot(t, u_adp_HPF, label='Input')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Voltage')\n",
    "plt.title('Input Signal with HPF')\n",
    "plt.legend()\n",
    "\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.plot(t, x1_adp_HPF[0,:], label='Height')\n",
    "plt.plot(t, x1_adp_HPF[1,:], label='Velocity')\n",
    "plt.plot(t, x1_adp_HPF[2,:], label='Motor Dynamics')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('State')\n",
    "plt.title('Height Control with tau = 2 with HPF')\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "id": "fc3ff499",
   "metadata": {},
   "outputs": [],
   "source": [
    "kron_xx = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "kron_xu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "delta_x = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "Ixx = np.empty((0, np.size(x1_adp_HPF,0)**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = np.size(x1_adp_HPF,0)*(np.size(x1_adp_HPF,0)+1)//2+np.size(x1_adp_HPF,0)*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l+1)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "id": "21478533",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp,0)\n",
    "Q = np.array([[5, 0, 0],[0, 1, 0], [0, 0, 1]])\n",
    "m = 1\n",
    "R_ = np.array([[1]])\n",
    "K_i = 0.2 * K_lqr1 # starting with a stabilizing control value\n",
    "N_ = create_N_matrix(n)\n",
    "\n",
    "K_adp = np.empty((0, np.size(x1_adp,0)))\n",
    "P_adp = []\n",
    "P_i_old = np.zeros_like(Q)\n",
    "\n",
    "norm_Pi = np.array([])\n",
    "\n",
    "for i in range(1,iterations):\n",
    "    # Calculating Q_i:\n",
    "    Q_i = Q + K_i.T @ R_ @ K_i\n",
    "    \n",
    "    # Calculating Y_i:\n",
    "    Y_i = -Ixx @ vec(Q_i) # Shai added - in the begining\n",
    "    X_i = np.hstack((delta_x @ N_, -2* Ixx@np.kron(np.eye(n), K_i.T @ R_) -2*Ixu @ np.kron(np.eye(n), R_)))\n",
    "    \n",
    "    # Calculating Theta_i:\n",
    "    Theta_i = np.linalg.lstsq(X_i, Y_i, rcond=None)[0]\n",
    "    \n",
    "    vecP_i = N_ @ Theta_i[:(n**2-n*m )]\n",
    "    P_i = vec2matrix(vecP_i)\n",
    "    norm_Pi = np.append(norm_Pi, np.linalg.norm(P_i))\n",
    "    \n",
    "    K_i = Theta_i[(n**2-2*m-1):].reshape(K_lqr1.shape)\n",
    "\n",
    "    \n",
    "    K_adp = np.vstack((K_adp, K_i))\n",
    "    P_adp.append(P_i)\n",
    "    \n",
    "    if abs(np.linalg.norm(P_i_old - P_i)) < 0.01:\n",
    "        print('Converged')\n",
    "        \n",
    "        break\n",
    "    \n",
    "    P_i_old = P_i\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "id": "cd120107",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_adp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "id": "b8c47cbd",
   "metadata": {},
   "outputs": [],
   "source": [
    "kron_xx = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "kron_xu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "delta_x = np.empty((0, np.size(x1_adp_HPF,0)**2))\n",
    "Ixx = np.empty((0, np.size(x1_adp_HPF,0)**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, np.size(x1_adp_HPF,0)))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = np.size(x1_adp_HPF,0)*(np.size(x1_adp_HPF,0)+1)//2+np.size(x1_adp_HPF,0)*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l+200)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "id": "003f59d7",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp,0)\n",
    "Q = np.array([[5, 0, 0],[0, 1, 0], [0, 0, 1]])\n",
    "m = 1\n",
    "R_ = np.array([[1]])\n",
    "K_i = 0.2 * K_lqr1 # starting with a stabilizing control value\n",
    "N_ = create_N_matrix(n)\n",
    "\n",
    "K_adp = np.empty((0, np.size(x1_adp,0)))\n",
    "P_adp = []\n",
    "P_i_old = np.zeros_like(Q)\n",
    "\n",
    "norm_Pi = np.array([])\n",
    "\n",
    "for i in range(1,iterations):\n",
    "    # Calculating Q_i:\n",
    "    Q_i = Q + K_i.T @ R_ @ K_i\n",
    "    \n",
    "    # Calculating Y_i:\n",
    "    Y_i = -Ixx @ vec(Q_i) # Shai added - in the begining\n",
    "    X_i = np.hstack((delta_x @ N_, -2* Ixx@np.kron(np.eye(n), K_i.T @ R_) -2*Ixu @ np.kron(np.eye(n), R_)))\n",
    "    \n",
    "    # Calculating Theta_i:\n",
    "    Theta_i = np.linalg.lstsq(X_i, Y_i, rcond=None)[0]\n",
    "    \n",
    "    vecP_i = N_ @ Theta_i[:(n**2-n*m )]\n",
    "    P_i = vec2matrix(vecP_i)\n",
    "    norm_Pi = np.append(norm_Pi, np.linalg.norm(P_i))\n",
    "    \n",
    "    K_i = Theta_i[(n**2-2*m-1):].reshape(K_lqr1.shape)\n",
    "\n",
    "    \n",
    "    K_adp = np.vstack((K_adp, K_i))\n",
    "    P_adp.append(P_i)\n",
    "    \n",
    "    if abs(np.linalg.norm(P_i_old - P_i)) < 0.01:\n",
    "        print('Converged')\n",
    "        \n",
    "        break\n",
    "    \n",
    "    P_i_old = P_i\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "id": "18eabd3f",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_adp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "id": "987f4fc7",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp_HPF,0)\n",
    "kron_xx = np.empty((0, n**2))\n",
    "kron_xu = np.empty((0, n))\n",
    "delta_x = np.empty((0, n**2))\n",
    "Ixx = np.empty((0, n**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, n))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = n*(n+1)//2+n*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l+200)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "id": "5aa1b3cc",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp_HPF,0)\n",
    "kron_xx = np.empty((0, n**2))\n",
    "kron_xu = np.empty((0, n))\n",
    "delta_x = np.empty((0, n**2))\n",
    "Ixx = np.empty((0, n**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, n))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = n*(n+1)//2+n*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l+500)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "id": "46be3421",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp,0)\n",
    "Q = np.array([[5, 0, 0],[0, 1, 0], [0, 0, 1]])\n",
    "m = 1\n",
    "R_ = np.array([[1]])\n",
    "K_i = 0.2 * K_lqr1 # starting with a stabilizing control value\n",
    "N_ = create_N_matrix(n)\n",
    "\n",
    "K_adp = np.empty((0, np.size(x1_adp,0)))\n",
    "P_adp = []\n",
    "P_i_old = np.zeros_like(Q)\n",
    "\n",
    "norm_Pi = np.array([])\n",
    "\n",
    "for i in range(1,iterations):\n",
    "    # Calculating Q_i:\n",
    "    Q_i = Q + K_i.T @ R_ @ K_i\n",
    "    \n",
    "    # Calculating Y_i:\n",
    "    Y_i = -Ixx @ vec(Q_i) # Shai added - in the begining\n",
    "    X_i = np.hstack((delta_x @ N_, -2* Ixx@np.kron(np.eye(n), K_i.T @ R_) -2*Ixu @ np.kron(np.eye(n), R_)))\n",
    "    \n",
    "    # Calculating Theta_i:\n",
    "    Theta_i = np.linalg.lstsq(X_i, Y_i, rcond=None)[0]\n",
    "    \n",
    "    vecP_i = N_ @ Theta_i[:(n**2-n*m )]\n",
    "    P_i = vec2matrix(vecP_i)\n",
    "    norm_Pi = np.append(norm_Pi, np.linalg.norm(P_i))\n",
    "    \n",
    "    K_i = Theta_i[(n**2-2*m-1):].reshape(K_lqr1.shape)\n",
    "\n",
    "    \n",
    "    K_adp = np.vstack((K_adp, K_i))\n",
    "    P_adp.append(P_i)\n",
    "    \n",
    "    if abs(np.linalg.norm(P_i_old - P_i)) < 0.01:\n",
    "        print('Converged')\n",
    "        \n",
    "        break\n",
    "    \n",
    "    P_i_old = P_i\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "id": "a4c21911",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_adp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "id": "77f7f4aa",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp_HPF,0)\n",
    "kron_xx = np.empty((0, n**2))\n",
    "kron_xu = np.empty((0, n))\n",
    "delta_x = np.empty((0, n**2))\n",
    "Ixx = np.empty((0, n**2)) # Initialize as an empty 2D array with shape (0, 2)\n",
    "Ixu = np.empty((0, n))\n",
    "dT = np.arange(0,iterations*T+T,T)\n",
    "l = n*(n+1)//2+n*1 # u is scalar so m=1. we have 2 states, therefore 2 equations. Q is 2x2. defining l this way will help us to set the window of the integrations in order to get a valid dimensions for Ixx and Ixu\n",
    "intr = int(iterations//(l+600)) # defining the interval for the integrations. this interval will give us Ixx and Ixu with the ammount of equations needed. In our case 2 equations.\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    x_i_1 = x1_adp_HPF[:,i-intr]\n",
    "    delta_xx_i = np.kron(x_i, x_i) - np.kron(x_i_1, x_i_1)\n",
    "    delta_x = np.vstack((delta_x, [delta_xx_i]))\n",
    "\n",
    "    \n",
    "for i in range(0,iterations):\n",
    "    x_i = x1_adp_HPF[:,i]\n",
    "    u_i = u_adp_HPF[i]\n",
    "    kron_xx_i = np.kron(x_i, x_i)\n",
    "    kron_xu_i = np.kron(x_i, u_i)\n",
    "    kron_xx = np.vstack((kron_xx, [kron_xx_i]))\n",
    "    kron_xu = np.vstack((kron_xu, [kron_xu_i]))\n",
    "\n",
    "for i in range(intr,iterations, intr):\n",
    "    window = slice(max(0, i-intr), i+1)  # This defines the time steps t0 to t1 etc.\n",
    "    new_Ixu = np.trapz(kron_xu[window,:], dT[window], axis = 0)\n",
    "    new_Ixx = np.trapz(kron_xx[window,:], dT[window], axis =0)\n",
    "    Ixu = np.vstack((Ixu, [new_Ixu]))\n",
    "    Ixx = np.vstack((Ixx, [new_Ixx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "id": "85141e01",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = np.size(x1_adp,0)\n",
    "Q = np.array([[5, 0, 0],[0, 1, 0], [0, 0, 1]])\n",
    "m = 1\n",
    "R_ = np.array([[1]])\n",
    "K_i = 0.2 * K_lqr1 # starting with a stabilizing control value\n",
    "N_ = create_N_matrix(n)\n",
    "\n",
    "K_adp = np.empty((0, np.size(x1_adp,0)))\n",
    "P_adp = []\n",
    "P_i_old = np.zeros_like(Q)\n",
    "\n",
    "norm_Pi = np.array([])\n",
    "\n",
    "for i in range(1,iterations):\n",
    "    # Calculating Q_i:\n",
    "    Q_i = Q + K_i.T @ R_ @ K_i\n",
    "    \n",
    "    # Calculating Y_i:\n",
    "    Y_i = -Ixx @ vec(Q_i) # Shai added - in the begining\n",
    "    X_i = np.hstack((delta_x @ N_, -2* Ixx@np.kron(np.eye(n), K_i.T @ R_) -2*Ixu @ np.kron(np.eye(n), R_)))\n",
    "    \n",
    "    # Calculating Theta_i:\n",
    "    Theta_i = np.linalg.lstsq(X_i, Y_i, rcond=None)[0]\n",
    "    \n",
    "    vecP_i = N_ @ Theta_i[:(n**2-n*m )]\n",
    "    P_i = vec2matrix(vecP_i)\n",
    "    norm_Pi = np.append(norm_Pi, np.linalg.norm(P_i))\n",
    "    \n",
    "    K_i = Theta_i[(n**2-2*m-1):].reshape(K_lqr1.shape)\n",
    "\n",
    "    \n",
    "    K_adp = np.vstack((K_adp, K_i))\n",
    "    P_adp.append(P_i)\n",
    "    \n",
    "    if abs(np.linalg.norm(P_i_old - P_i)) < 0.01:\n",
    "        print('Converged')\n",
    "        \n",
    "        break\n",
    "    \n",
    "    P_i_old = P_i\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "id": "f42072a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "K_adp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "id": "6c016cec",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import math\n",
    "import scipy as sp\n",
    "import control as ct\n",
    "import control.matlab as matlab\n",
    "from HelperFunctions import *\n",
    "from scipy.signal import butter, lfilter\n",
    "\n",
    "% notebook inline"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}
